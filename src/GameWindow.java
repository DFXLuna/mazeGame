 /**
 * @author Group L
 * Matt Grant, Adam Coggeshall, Jared Frank, Alex Germann, Auston Larson
 * COSC 3011 Program 01
 * GameWindow.java
 */

import javax.swing.*;
import java.util.ArrayList;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

public class GameWindow extends JFrame implements ActionListener, MouseListener
  {
    /**
     * because it is a serializable object, need this or javac
     * complains a lot
     */
    public static final long serialVersionUID=1;
    
    private ArrayList<FrontEndTileHolder> tileHolders = new ArrayList<FrontEndTileHolder>();
    
    private Messenger messenger;
    
    /**
     * The constructor sets up the UI.
     * We pass it a reference to the backend GameBoard. -AC
     */
    public GameWindow(Messenger messenger)
    {
      super("Group L aMaze");
      
      this.messenger = messenger;
      
      setupUI();
      setupGame();
    }

    /**
     *  Sets up the UI.
     *  Also sets the initial position of the board and tiles. -AC
     */

    public void setupUI()
    {
      setSize(new Dimension(900, 1000));
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      getContentPane().setBackground(Color.cyan);
      
      addMouseListener(this);
      this.addButtons();
      
      setVisible(true);
    }
    
    /**
     * Sets up the visual representation of tile containers.
     */
    public void setupGame() {
      FrontEndGameBoard board =
          new FrontEndGameBoard(messenger, 290, 300);
      
      FrontEndSideHolder leftSide =
          new FrontEndSideHolder(messenger, BoardSide.LEFT, 50, 80);
      
      FrontEndSideHolder rightSide = 
          new FrontEndSideHolder(messenger, BoardSide.RIGHT, 770, 80);
      
      tileHolders.add( board );
      tileHolders.add( leftSide );
      tileHolders.add( rightSide );
    }
    
    
    /**
     * Used by setupUI() to create and configure the buttons. -AC
     */
    public void addButtons(){
      
      // We decided to create the layout here, and use a FlowLayout.
      // It handles buttons much more naturally than a GridLayout.
      // If we really need to add more elements using more advanced
      // layout, we can add another container later. -AC
      FlowLayout button_layout = new FlowLayout(FlowLayout.LEFT, 5, 5);
      this.setLayout(button_layout);
      
      Button btn_new = new Button("New Game");
      btn_new.setActionCommand("new");
      btn_new.addActionListener(this);
      this.add(btn_new);
      
      Button btn_reset = new Button("Reset");
      btn_reset.setActionCommand("reset");
      btn_reset.addActionListener(this);
      this.add(btn_reset);
      
      Button btn_quit = new Button("Quit");
      btn_quit.setActionCommand("quit");
      btn_quit.addActionListener(this);
      this.add(btn_quit);
    }
    
    // Here we handle events generated by the buttons. -AC
    @Override
    public void actionPerformed(ActionEvent e) {
      switch (e.getActionCommand()) {
      case "new":
        System.out.println("New Game");
        break;
      case "reset":
        System.out.println("Reset");
        break;
      case "quit":
        System.exit(0);
        break;
      }
    }
    
    
    /**
     * We decided to draw the game board and tiles ourselves, rather than
     * extending UI components. This now calls the draw method of each
     * tile holder. The tile holders are responsible for drawing their
     * tiles. -AC
     */
    @Override
    public void paint(Graphics g) {
      super.paint(g);
      
      for (FrontEndTileHolder holder : tileHolders) {
        holder.draw(g);
      }
    }
    
    // Here we handle mouse input. We end up with some empty methods since
    // we're using the MouseListener interface.
    
    @Override
    public void mouseClicked(MouseEvent e) {
      // Do nothing. -AC
    }

    @Override
    public void mouseEntered(MouseEvent e) {
      // Do nothing. -AC
    }

    @Override
    public void mouseExited(MouseEvent e) {
      
    }

    @Override
    public void mousePressed(MouseEvent e) {
      for (FrontEndTileHolder holder : tileHolders) {
        int tileNumber = holder.getTileNumberFromClick(e);
        // If there is a tile present, then we can start the drag!
        if (tileNumber >= 0) {
          int slot = holder.getSlotFromClick(e);
          messenger.setDragInfo(slot, tileNumber);
          this.repaint();
          break;
        }
      }
    }

    @Override
    public void mouseReleased(MouseEvent e) {
      if (messenger.getDraggedTileNumber() >= 0) {
        for (FrontEndTileHolder holder : tileHolders) {
          int slot = holder.getSlotFromClick(e);
          // If we have a destination slot, do a swap. --AC
          if (slot >= 0) {
            messenger.movetile( messenger.getDragSourceSlot(), slot);
            break;
          }
        }
        messenger.clearDragInfo();
        this.repaint();
      }
    }
  };
